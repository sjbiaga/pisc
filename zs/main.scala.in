/*
 * Copyright (c) 2023-2025 Sebastian I. Gliţa-Catina <gseba@users.sourceforge.net>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * [Except as contained in this notice, the name of Sebastian I. Gliţa-Catina
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * from Sebastian I. Gliţa-Catina.]
 */

//package main.scala.in

import _root_.zio.{ FiberRef, Promise, Queue, Semaphore, ZIO }
import _root_.zio.stm.TSemaphore
import _root_.zio.stream.ZStream


object App extends _root_.zio.ZIOAppDefault:

  private val bacsp = "pisc.bioambients.communications.parallelism.level"
  private val baass = "pisc.bioambients.ambients.hierarchy.snapshot"


  import _root_.scala.collection.immutable.{ List, Map }

  import _root_.zio.{ ExitCode, Ref }

  import _root_.zio.ZIOAppArgs

  import `Π-dump`.*
  import `Π-loop`.*


  private def run(args: List[String], snapshot: Boolean, uuid: sΠ.`)(`)
                 (% : %, / : /, * : *, - : -, ! : !, & : &, ~ : ~)
                 (using sΠ.`}{`.`][`, TSemaphore) =
    ( for
        r <- ZStream.fromZIO(ZIO.scoped(FiberRef.make[sΠ.`)(`](uuid)))
        ^ <- ZStream.fromZIO(π.`π-uuid`)
        _ <- π.Main(r)(args*)(using ^)(using %, /, () => *.offer(()).unit)
        x <- ZStream.fromZIO(!.await)
        _ <- ZStream.fromZIO(exit(x))
      yield
        ()
    )
      .drainFork(ZStream.fromZIO(loop(snapshot)(using %, !, &, ~, -, *)(π.`π-wand`)))
      .drainFork(ZStream.fromZIO(poll(using %, /, *)))
      .drainFork(ZStream.fromZIO(dump(snapshot)(using %, !, -)))
      .runDrain

  override def run: ZIO[ZIOAppArgs, Throwable, Unit] =
    val p = if sys.Prop.IntProp(bacsp).isSet
            then sys.Prop.IntProp(bacsp).value
            else π.`π-parallelism`
    val s = if sys.BooleanProp.keyExists(baass).value
            then true
            else π.`π-snapshot`
    for
      args <- getArgs
      % <- Ref.make(Map[String, Int | (Boolean, +)]())
      / <- Queue.unbounded[((String, String), +)]
      * <- Queue.unbounded[Unit]
      - <- Queue.unbounded[List[String] | (Long, ((Long, Long), Long), (String, String), (Double, Double), (Promise[Throwable, (String, (String, String))], Promise[Throwable, (String, (String, String))]))]
      ! <- Promise.make[Throwable, ExitCode]
      & <- Ref.make(0L)
      ~ <- Semaphore.make(p)
      _ <- sΠ.`π-enable`(π.`π-main`)(using %)
      (uuid, tree, semaphore) <- sΠ.`}{`.`][`()
      _ <- run(args.toList, s, uuid)(%, /, *, -, !, &, ~)(using tree, semaphore)
    yield
      ()


object π:

  import _root_.scala.collection.immutable.{ List => πLs }

  import _root_.zio.{ durationLong, Exit, Random, Scope, Task, UIO, ZLayer }
  import _root_.zio.concurrent.CyclicBarrier

  import _root_.eu.timepit.refined.*

  import sΠ.*
  import `π-$`.*, `π-ζ`.*

  import `Π-loop`.{ %, /, \ }
  import `Π-stats`.{ ∞, `ℝ⁺`, ⊤ }


  extension (self: πLs[ZStream[Any, Throwable, ?]])
    private[π] inline def πcollectAllParZIO: ZIO[Any, Throwable, Unit] =
      ZIO.collectAllParDiscard(self.map(_.runDrain))
    private[π] inline def πcollectAllPar: ZStream[Any, Throwable, Unit] =
      ZStream.fromZIO(self.πcollectAllParZIO)
    private[π] inline def πcollectAllPar(semaphore: Semaphore): ZStream[Any, Throwable, Unit] =
      ZStream.fromZIO(ZIO.collectAllParDiscard(self.map(_.runDrain).map(semaphore.tryWithPermit(_))))

  val `π-uuid`: UIO[String] =
    Random.nextUUID.map(_.toString)


