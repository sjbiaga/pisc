# -*- indent-tabs-mode: nil; -*-

@import cats.effect.Async

@val gen = new scala.util.Random

⟦ typeclasses = (Async,Concurrent,ContextShift,Timer,TaskLift,TaskLike) ⟧

⟦ exclude = yes ⟧

# one infinite producer, one infinite consumer ✔

Main = ν(x) ( (! 100,milliseconds .x</*Async[F].delay(gen.nextInt)*/>.)  \
            | (!.x(y). τ/*Async[F].delay(println(y))*/.)                 \
            )

⟦ exclude = yes ⟧

# two infinite producers, one infinite consumer ✔

Main = ν(x) ( (! 100,milliseconds .x</*Async[F].delay(gen.nextInt.abs)*/>.)   \
            | (! 100,milliseconds .x</*Async[F].delay(-gen.nextInt.abs)*/>.)  \
            | (!.x(y). τ/*Async[F].delay(println(y))*/.)                      \
            )

⟦ exclude = yes ⟧

# two finite producers, one infinite consumer ✔

Main = ν(x) ( (x</*Async[F].delay(gen.nextInt.abs)*/>.)                     \
            | (x</*Async[F].delay(-gen.nextInt.abs)*/>.)                    \
            | (! 100,milliseconds .x(y). τ/*Async[F].delay(println(y))*/.)  \
            )

⟦ exclude = yes ⟧

# two sequential finite producers, one infinite consumer ✔

Main = ν(x) ( (x</*Async[F].delay(gen.nextInt.abs)*/>. x</*Async[F].delay(-gen.nextInt.abs)*/>.)  \
            | (! 100,milliseconds .x(y). τ/*Async[F].delay(println(y))*/.)                        \
            )

⟦ exclude = yes ⟧

# two infinite producers, two infinite consumers ✔

Main = ν(x) ( (! 100,milliseconds .x</*Async[F].delay(gen.nextInt.abs)*/>.)   \
            | (! 100,milliseconds .x</*Async[F].delay(-gen.nextInt.abs)*/>.)  \
            | (!.x(y). τ/*Async[F].delay(println(1->y))*/.)                   \
            | (!.x(y). τ/*Async[F].delay(println(2->y))*/.)                   \
            )

⟦ exclude = yes ⟧

# one infinite producer, one infinite consumer, bound output guard ✔

Main = ν(x) ( (! 100,milliseconds .x<νy>. y(z). τ/*Async[F].delay(println(z))*/.)  \
            | (!.x(y). y</*Async[F].delay(gen.nextInt)*/>.)                        \
            )

⟦ exclude = yes ⟧

# one finite producer, one finite consumer, bound output prefix ✔

Main = ν(x) ! ( (x<νy>. y(z). τ/*Async[F].delay(println(z))*/.)  \
              | (x(y). y</*Async[F].delay(gen.nextInt)*/>.)      \
              )

⟦ exclude = yes ⟧

# one finite producer, one finite consumer, output prefix ✔

Main = ν(x) ! ( (x(y). τ/*Async[F].delay(println(y))*/.)  \
              | (x</*Async[F].delay(gen.nextInt)*/>.)     \
              )

⟦ exclude = yes ⟧

# one infinite producer, multiple finite consumers ✔

Main = ν(x) ( (! x(y). τ/*Async[F].delay(println(y))*/.)  \
            | (!.x</*Async[F].delay(gen.nextInt)*/>.)     \
            )

⟦ exclude = yes ⟧

# one infinite producer, multiple finite consumers ✔

Main(x) = x(y). τ/*Async[F].delay(println(y))*/. Main(x)

Main = ν(x) ( Main(x)                                  \
            | (!.x</*Async[F].delay(gen.nextInt)*/>.)  \
            )

⟦ exclude = yes ⟧

# two finite producers, multiple finite consumers ✔

Main = ν(x) ( (! x(y). τ/*Async[F].delay(println(y))*/.)  \
            | (x</*Async[F].delay(gen.nextInt)*/>.)       \
            | (x</*Async[F].delay(gen.nextInt)*/>.)       \
            )

⟦ exclude = yes ⟧

# two finite producers, multiple finite consumers ✔

Main(x) = x(y). τ/*Async[F].delay(println(y))*/. Main(x)

Main = ν(x) ( Main(x)                                \
            | (x</*Async[F].delay(gen.nextInt)*/>.)  \
            | (x</*Async[F].delay(gen.nextInt)*/>.)  \
            )

⟦ exclude = yes ⟧

# one infinite producer, two sequential finite consumers ✔

Main = ν(x) ( (x(y). τ/*Async[F].delay(println(1->y))*/. x(z). τ/*Async[F].delay(println(2->z))*/.)  \
            | (!.x</*Async[F].delay(gen.nextInt)*/>.)                                                \
            )

⟦ exclude = no ⟧

# multiple finite producers, one infinite consumer ✕

Main = ν(x) ( (!.x(y). τ/*Async[F].delay(println(y))*/. x</*Async[F].delay(gen.nextInt.abs)*/>.)  \
            | (x</*Async[F].delay(-gen.nextInt.abs)*/>.)                                          \
            )

⟦ exclude = yes ⟧

# multiple finite producers, one infinite consumer, one finite consumer ✔

Main = ν(x) ( (!.x(y). τ/*Async[F].delay(println(1->y))*/. x</*Async[F].delay(gen.nextInt.abs)*/>. x(y). τ/*Async[F].delay(println(2->y))*/.)  \
            | (x</*Async[F].delay(-gen.nextInt.abs)*/>.)                                                                                       \
            )
