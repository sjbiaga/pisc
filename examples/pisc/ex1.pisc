# -*- indent-tabs-mode: nil; -*-

@import eu.timepit.refined.numeric.*

⟦ scaling = on ⟧

P(e, f, g) = 2 * ( (ν(x, y) x<5>. x<6>. ν(z) x(a : Int /* NonNegative */). a<z>. ν(w) w(b). b<w>. z(c). c<y>.) + (e<f>. e<f>. g(w). ν(z) g(a). a<z>. z(b). b<z>. b(f). ν(h) ( P(e, f, g) + P(e, f, h) )) )

A(x) = ( ! 2 * 1,second .x<5>. x<6>. ) | ( ν(j) j(j). j<j>. ν(i) i(k). ! 3 * 1,minute .x<νy>. y<7>. )

B(x) = x<x>. ! 3 * 1,minute .x(y : Int /**/). y<7>.

B'(x) = x<x>. x(w). ν(y) ! 3 * 1,minute .x(z : Int /**/). z<8>.

C(x) = 2 * 1 * x<x>. ! 2 * Q

D(x) = 1 * 2 * ( ( x<x>. ! 2 * Q ) | ( x<x>. ν(b) b(c). ! 2 * Q ) )

Q(z) = ν(w) z<w>. z(a). ν(b) [/*1*/ = 2] (ν(x) x<5>. x(y). y<6>.)

R = if 1 = 2 then (ν(x) x<5>. x(y). y<6>.) else (ν(x) x(y). y<7>. y(z).)

# ⟦ t"1st ${$A} or ${$B}" ⟧ = τ.A{} + τ.τ.B{}

# ⟦ t"2nd ${$P} and ${$Q}" ⟧ = ⟦ 1st P{} or () ⟧ | Q{}

X = ( 1 * 2 * P ) | ( 1 * 3 * Q )

Y = 1 * 2 * P | ( 1 * 3 * Q )

Z = 1 * 2 * P | ( 3 * Q )

# Main = ν(x, y) ⟦ 2nd x<y>. and x(z). ⟧

⟦ 'P ^ 'Q ⟧{x,y} = P{x} | Q{y}
⟦ 'P ^ 'Q ^ 'R ⟧{x,y,z} = P{x} | R{y} | Q{z}

⟦1 t"Out" 1⟧{z} = z<z>.

⟦2 t"In" 2⟧{w} = w(z).τ/*println('z)*/.

⟦3 t"Comm" 3⟧ = ν(ch) ⟦ ⟦ ⟦1 Out 1⟧ ^ ⟦2 In 2⟧ ⟧ ^ ⟦ ⟦1 Out 1⟧ ^ ⟦2 In 2⟧ ⟧ ⟧{ch, ch}

⟦ push = scaling ⟧

⟦ scaling = false ⟧

Main = ν(a) a<νb>. ⟦ Comm ⟧ + ⟦ Comm ⟧
# Main = ν(a) ! .a<νb>. ⟦ Comm ⟧ + ⟦ Comm ⟧
# Main = ν(a) ! 3 * .a<νb>. ⟦ Comm ⟧ + ⟦ Comm ⟧

⟦ pop = 1 ⟧


# ⟦ 'P ^ 'Q ⟧{x,y} = P{x} | Q{y}
# Agent0 = ()
# Agent2(a, b) = a<b>.()
# ⟦ t"Process1" ⟧ = ν(x, y) ⟦ ν(x) Agent2(){x} ^ Agent0 ⟧{x, y}
# # Process2 = ν(x, y) ⟦ ν(x) Agent2(x, x) ^ Agent0 ⟧{y, y}
# # Main = Process1 | Process2
# Main2 = ⟦ Process1 ⟧


# ⟦3 s"${a}Comm${b}" 3⟧ = ν(ch) ⟦ ⟦1 Out 1⟧ ^ ⟦2 In 2⟧ ⟧{ch, ch} + a<b>.
# ⟦4 x Do 'c 4⟧ = ⟦3 c Comm c 3⟧ | ⟦3 c Comm c 3⟧
# Main = ν(d) ( ⟦4 Do d 4⟧ + ⟦4 Do d 4⟧ )

# ⟦1 s"Nil" 1⟧(nil){k} = k<nil>.

# ⟦2 'L1 Cons 'L2 2⟧(cons){x} =                     \
#                     ν(y, z) ( x<cons>.x<y>.x<z>.  \
#                             | L1{y}               \
#                             | L2{z}               \
#                             )

# Eq(x, nil, cons) = ⟦2 ⟦2                           \
#                          ⟦1 Nil 1⟧ Cons ⟦1 Nil 1⟧  \
#                       2⟧                           \
#                       Cons                         \
#                       ⟦1 Nil 1⟧                    \
#                    2⟧{x}

# # Ne(x, nil, cons) = ⟦2 ⟦1 Nil 1⟧  \
# #                       Cons       \
# #                       ⟦1 Nil 1⟧  \
# #                    2⟧{x}

# Main = ν(t, f, nil, cons) ν(x, y) ( Eq(x, nil, cons) | Eq(y, nil, cons) )


# # # ⟦ 'x :: 'y ==> 'P || 'z ==> 'Q ⟧ = x(w).(([w = y]P{}) + ([w = z]Q{}))

# # # ⟦2 'y Copy 'z 2⟧(t, f) = ν(w) ⟦ w :: t ==> z<t>. || f ==> z<f>. ⟧ | ⟦ y :: t ==> z<t>. || f ==> z<f>. ⟧

# # # ⟦11 s"True $x" 11⟧(t, f) = x<t>.

# # # ⟦3 'a Copy 'b 3⟧(t, f) = ⟦2 a Copy b 2⟧

# # # Main = ν(t, f) ν(x, y) ( ⟦11 True x 11⟧                   \
# # #                        | ⟦2 x Copy y 2⟧                   \
# # #                        | ⟦ y :: t ==> τ/*println("T")*/.  \
# # #                              || f ==> τ/*println("F")*/.  \
# # #                          ⟧                                \
# # #                        )


# # # Main = ν(x)ν(y)(x<y>. | x(z).(([y=z]()) | (([x = y][y = x][y ≠ z]τ/*println(1)*/.) + ([x = y][y = z]τ/*println(2)*/.) + ([y ≠ z][x = y]τ/*println(3)*/.) + ([y = z]τ/*println(4)*/.)) ))
